package com.example.nido.ui.views

import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.layout.*
import androidx.compose.material3.Button
import androidx.compose.material3.Text
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.input.pointer.consume
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import com.example.nido.data.model.Card
import com.example.nido.data.model.Hand
import com.example.nido.utils.SortMode
import com.example.nido.utils.println
import com.example.nido.utils.TRACE
import com.example.nido.utils.TraceLogLevel.*
import com.example.nido.ui.theme.NidoColors
import com.example.nido.utils.Constants
import com.example.nido.ui.views.CardView
import kotlinx.coroutines.launch

// ðŸš€ NEW: Make sure you have your original sortedByMode extension function defined in your project:
// fun List<Card>.sortedByMode(mode: SortMode): List<Card> {
//     return when (mode) {
//         SortMode.FIFO -> this // No sorting, keep as is
//         SortMode.COLOR -> this.sortedWith(compareBy({ it.color.ordinal }, { it.value }))
//         SortMode.VALUE -> this.sortedBy { it.value }
//     }
// }

@Composable
fun HandView(
    hand: Hand,
    cardWidth: Dp,
    cardHeight: Dp,
    sortMode: SortMode,
    onDoubleClick: () -> Unit,
    onSelectCard: (Card) -> Unit
) {
    val coroutineScope = rememberCoroutineScope()
    val density = LocalDensity.current
    val cardHeightPx = with(density) { cardHeight.toPx() }

    TRACE(VERBOSE) { "Recomposing HandView : ${hand.cards}" }

    Box(
        modifier = Modifier
            .background(NidoColors.HandViewBackground2)
            .padding(bottom = 8.dp)
    ) {
        // ðŸš€ NEW: Use sorted cards based on sortMode with the restored sorting logic
        val sortedCards by remember(hand.cards, sortMode) {
            derivedStateOf {
                hand.cards.sortedByMode(sortMode)
            }
        }

        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.Center
        ) {
            sortedCards.indices.forEach { index ->
                val card = sortedCards[index] // Using sorted list now
                var offsetY by remember { mutableStateOf(0f) }
                var dragging by remember { mutableStateOf(false) }

                Box(
                    modifier = Modifier
                        .shadow(if (dragging) 8.dp else 0.dp)
                        // ðŸš€ NEW: Convert offset from pixels to dp using LocalDensity
                        .offset(y = with(density) { offsetY.toDp() })
                        .pointerInput(card) { // ðŸ”„ Changed key from Unit to card so the lambda updates when card changes
                            detectDragGestures(
                                onDragStart = {
                                    dragging = true
                                    // ðŸ”„ Using the captured 'card' rather than reading from sortedCards[index]
                                    TRACE(VERBOSE, tag = "HandView:onDragStart1") { "Dragging card: ${card.value}, ${card.color}, index = $index" }
                                },
                                onDragEnd = {
                                    dragging = false
                                    TRACE(VERBOSE, tag = "HandView:onDragEnd") { "Drag End card: ${card.value}, ${card.color}, index = $index" }

                                    // âœ… Check if drag threshold is reached
                                    if (offsetY < -cardHeightPx / 2) {
                                        coroutineScope.launch {
                                            if (hand.cards.contains(card)) {
                                                val removed = hand.removeCard(card)
                                                if (removed) {
                                                    TRACE(DEBUG, tag = "HandView:onDragEnd") { "âœ… Successfully selected card: ${card.value}, ${card.color}" }
                                                    onSelectCard(card)
                                                } else {
                                                    TRACE(ERROR, tag = "HandView:onDragEnd") { "Failed to remove card: ${card.value}, ${card.color}" }
                                                }
                                            } else {
                                                TRACE(ERROR, tag = "HandView:onDragEnd") { "Card not found in hand: ${card.value}, ${card.color}" }
                                            }
                                        }
                                    } else {
                                        TRACE(VERBOSE, tag = "HandView:onDragEnd") { "Drag threshold not reached" }
                                    }
                                    offsetY = 0f
                                },
                                onDragCancel = {
                                    TRACE(VERBOSE, tag = "HandView:onDragCancel") { "Drag canceled" }
                                    dragging = false
                                    offsetY = 0f
                                },
                                onDrag = { change, dragAmount ->
                                    change.consume()
                                    offsetY += dragAmount.y
                                    TRACE(VERBOSE, tag = "HandView:onDrag") { "dragAmount: $dragAmount" }
                                }
                            )
                        }
                ) {
                    CardView(
                        card = card,
                        modifier = Modifier.size(cardWidth, cardHeight)
                    )
                }
            }
        }
    }
}
